/**
 * Entry point: loads WASM, wires UI, runs generation pipeline.
 * Phase 7, Task P7.8.
 */

import { initSliders, type GlobalParams } from "./ui/sliders.js";
import { renderScorePanel, type RealismScoreData } from "./ui/score_panel.js";
import { renderHeightField, type RenderMode } from "./render.js";
import { exportAs16BitPng, exportAsFloat32Binary, type ExportMetadata } from "./export.js";

// ── WASM import ────────────────────────────────────────────────────────────────
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore — generated by wasm-pack, path resolved at build time
import init, { generate } from "../../crates/terra-wasm/pkg/terra_wasm.js";

// ── State ──────────────────────────────────────────────────────────────────────

interface PlanetResult {
  heights: number[];
  regimes: number[];
  map_field: number[];
  width: number;
  height: number;
  score: RealismScoreData;
  generation_time_ms: number;
}

let lastResult: PlanetResult | null = null;
let renderMode: RenderMode = "hillshade";

// ── DOM refs ───────────────────────────────────────────────────────────────────

const canvas        = document.getElementById("main-canvas")    as HTMLCanvasElement;
const scorePanel    = document.getElementById("score-panel")    as HTMLDivElement;
const statusEl      = document.getElementById("status")         as HTMLDivElement;
const generateBtn   = document.getElementById("generate-btn")   as HTMLButtonElement;
const exportDiv     = document.getElementById("export-buttons") as HTMLDivElement;
const progressCont  = document.getElementById("progress-bar-container") as HTMLDivElement;
const progressBar   = document.getElementById("progress-bar")   as HTMLDivElement;

// ── Slider init ────────────────────────────────────────────────────────────────

const slidersContainer = document.getElementById("sliders-container") as HTMLElement;
const getParams = initSliders(slidersContainer);

// ── Mode buttons ───────────────────────────────────────────────────────────────

document.querySelectorAll(".mode-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".mode-btn").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    renderMode = (btn as HTMLElement).dataset.mode as RenderMode;
    if (lastResult) renderResult(lastResult);
  });
});

// ── Tile-worker render ─────────────────────────────────────────────────────────

function renderResult(result: PlanetResult): void {
  const { width, height } = result;
  const data = new Float32Array(result.heights);
  const regs = new Uint8Array(result.regimes);

  // Compute min/max once.
  let min = Infinity, max = -Infinity;
  for (const v of data) { if (v < min) min = v; if (v > max) max = v; }

  canvas.width  = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d")!;

  // Four quadrants: top-left, top-right, bottom-left, bottom-right.
  const midX = Math.floor(width  / 2);
  const midY = Math.floor(height / 2);
  const tiles = [
    [0, 0, midX, midY],
    [midX, 0, width, midY],
    [0, midY, midX, height],
    [midX, midY, width, height],
  ] as const;

  progressCont.style.display = "block";
  let done = 0;

  const heightsBuf = data.buffer.slice(0) as ArrayBuffer;
  const regsBuf    = regs.buffer.slice(0) as ArrayBuffer;

  tiles.forEach(([x0, y0, x1, y1]) => {
    const worker = new Worker(new URL("./workers/tile_worker.ts", import.meta.url), { type: "module" });
    worker.postMessage(
      { heights: heightsBuf.slice(0), regimes: regsBuf.slice(0),
        fullWidth: width, fullHeight: height,
        x0, y0, x1, y1, mode: renderMode, min, max },
      [heightsBuf.slice(0), regsBuf.slice(0)],
    );
    worker.onmessage = (e: MessageEvent) => {
      const { pixels, x0: tx0, y0: ty0, x1: tx1, y1: ty1 } = e.data as {
        pixels: ArrayBuffer; x0: number; y0: number; x1: number; y1: number;
      };
      const tileW = tx1 - tx0;
      const tileH = ty1 - ty0;
      const imgData = new ImageData(new Uint8ClampedArray(pixels), tileW, tileH);
      ctx.putImageData(imgData, tx0, ty0);
      done++;
      progressBar.style.width = `${(done / 4) * 100}%`;
      if (done === 4) {
        progressCont.style.display = "none";
        progressBar.style.width = "0%";
      }
      worker.terminate();
    };
  });
}

// ── Generate button ────────────────────────────────────────────────────────────

async function runGenerate(): Promise<void> {
  const params: GlobalParams = getParams();
  generateBtn.disabled = true;
  statusEl.textContent = "Generating…";

  try {
    // generate() is synchronous in WASM (no async needed for the single-threaded case).
    const result = generate(params) as PlanetResult;
    lastResult = result;

    renderResult(result);
    renderScorePanel(scorePanel, result.score, result.generation_time_ms);
    exportDiv.classList.add("visible");
    statusEl.textContent = `Done — ${result.generation_time_ms} ms`;
  } catch (err) {
    statusEl.textContent = `Error: ${err}`;
    console.error(err);
  } finally {
    generateBtn.disabled = false;
  }
}

generateBtn.addEventListener("click", () => { void runGenerate(); });

// ── Export buttons ─────────────────────────────────────────────────────────────

document.getElementById("btn-png")!.addEventListener("click", () => {
  if (!lastResult) return;
  const params = getParams();
  const data = new Float32Array(lastResult.heights);
  let min = Infinity, max = -Infinity;
  for (const v of data) { if (v < min) min = v; if (v > max) max = v; }
  const meta: ExportMetadata = {
    params: params as unknown as Record<string, unknown>,
    score_total: lastResult.score.total,
    width: lastResult.width,
    height: lastResult.height,
    min_elevation: min,
    max_elevation: max,
    generation_time_ms: lastResult.generation_time_ms,
    timestamp: new Date().toISOString(),
  };
  void exportAs16BitPng(data, lastResult.width, lastResult.height, meta);
});

document.getElementById("btn-raw")!.addEventListener("click", () => {
  if (!lastResult) return;
  const params = getParams();
  const data = new Float32Array(lastResult.heights);
  let min = Infinity, max = -Infinity;
  for (const v of data) { if (v < min) min = v; if (v > max) max = v; }
  const meta: ExportMetadata = {
    params: params as unknown as Record<string, unknown>,
    score_total: lastResult.score.total,
    width: lastResult.width,
    height: lastResult.height,
    min_elevation: min,
    max_elevation: max,
    generation_time_ms: lastResult.generation_time_ms,
    timestamp: new Date().toISOString(),
  };
  exportAsFloat32Binary(data, meta);
});

// ── WASM init ──────────────────────────────────────────────────────────────────

(async () => {
  try {
    await init();
    generateBtn.disabled = false;
    statusEl.textContent = "Ready.";

    // Render a flat placeholder so the canvas is not blank on load.
    const flat = new Float32Array(800 * 400).fill(0);
    renderHeightField(canvas, flat, 800, 400, "hillshade");
  } catch (err) {
    statusEl.textContent = `WASM load failed: ${err}`;
    console.error(err);
  }
})();
